---
title: "5. Spatial point patterns"
author: "Ana J. Alegre (jalegre@centrogeo.edu.mx), Cristian Silva (csilva@centrogeo.edu.mx)"
output: html_notebook
date: "11/3/2021"
---

## Introduction

## Objective

## Data preparation

Load the packages to be used:
```{r Load packages}
library(tidyverse)
library(sf)
library(raster)
library(spatstat)
library(tmap)
```

Read the murders data points for CDMX:
```{r Read murder data}
murders_cdmx <-
  st_read("Data/murders_cdmx.gpkg") %>% 
  st_transform(6369) %>% # Transform CRS from WGS84 geographic coordinates to projected Mexico ITRF2008 UTM Z14N
  filter(!st_is_empty(geom)) %>% # Omit all features with empty geometry
  glimpse()
```

```{r}
cdmx_border <-
  st_read("Data/cdmx_border.gpkg") %>% 
  st_transform(6369) # Transform CRS from WGS84 geographic coordinates to projected Mexico ITRF2008 UTM Z14N

qtm(cdmx_border) # Quickly visualize CDMX polygon
```
Create an *observation window* to frame the resulting raster, converting the `cdmx_border` *sf layer* with the function `as.owin`:
```{r}
cdmx_window <- as.owin(cdmx_border)
```

Convert the murders *sf layer* to *planar point pattern* (`ppp`) using the function `as.ppp`:
```{r}
murders_ppp <- as.ppp(murders_cdmx)
```

By default `as.ppp` uses the points extents as observation window, change it using the `Window` function to use the `cdmx_window` defined below:
```{r}
Window(murders_ppp) <- cdmx_window
```

## Analyzing spatial point patterns

### Spatial point distribution

Check if the spatial point distribution is random, using Chi square testing:
```{r}
quadrat.test(murders_ppp, nx = 100, ny = 100)
```

As can be seen in the results of this test, the hypothesis of randomness is rejected, i.e., there is a pattern of accumulation of homicides in certain places.

### Ripley's K

With Ripley's K function we can identify clusters, taking into account the spatial dependence of the points within predefined distances and increments. In addition, it allows us to make inferences about the existence of other possible points, based on the distribution of the observed ones.

With this function, Ripley's K, we are interested in seeing the red dotted line and the black line. The first shows how the theoretical distribution of the points should be. The second shows how they are distributed according to the observed points. When the black line is above the red line it means that there is clustering. In addition, it shows the distances in meters where other points may exist (x-axis).

Calculate Ripley's K without correction and 99 simulations, using `envelope` function with `fun = Kest`:
```{r}
murders_k <- envelope(murders_ppp, fun = Kest, nrank = 2, nsim = 99, correction = "none") # Without correction
# murders_k <- envelope(murders_ppp, fun = Kest, nrank = 2, nsim = 99, correction = "best") # Optionally using correction
```

Visualize outcomes using default `plot` function:
```{r}
plot(murders_k, main = "Ripley's K for murders in CDMX")
```

### L function

The centered version of the function K is K (r) - Kpois (r) = K (r) - πr2. This can be useful for classifying a pattern of points as random, clustered, or regular, because the function is zero if the pattern of points is completely random. It is less useful for other purposes.
A commonly used K-transformation proposed by Besag [103] is the Ln function that transforms the Poisson theoretical K-function Kpois (r) = πr2 into the straight line Lpois (r) = r, which facilitates visual evaluation of the plot.

Calculate *L function* for the murders, using `Lest` function:
```{r}
murders_l <- Lest(murders_ppp)
```

Visualize outcomes using default `plot` function:
```{r}
plot(murders_l, main = "L function for murders in CDMX")
```

### G function: Distance to the nearest event

The *G function* measures the distribution of distances from an arbitrary event to the nearest event. The distances are defined as d_i= 〖min〗_j {d_ij,∀j≠i},i=1,...,n , then the G function can be estimated as:

G ̂(r)=(#{d_i ∶ d_i≤r,∀i})/n

where the numerator is the number of elements in the set of distances that are less than or equal to r and n is the total number of points. Under the randomness conditions the value of the function G is.

G(r)=1-exp{-λπr^2}

where λ represents the average number of events per unit area (intensity). Compatibility with the point pattern complete spatial randomness (CSR) hypothesis can be tested by plotting the empirical function G ̂(r) against the expected theoretical value G(r).

Calculate *G function* with 99 simulations, using `envelope` function with `fun = Gest`:
```{r}
murders_g <- envelope(murders_ppp, fun = Gest, nrank = 2, nsim = 99)
```

Visualize outcomes using default `plot` function:
```{r}
plot(murders_g, main = "G function: Distance to the nearest murder event in CDMX")
```

### F function: Distance from a random point to the nearest event

The *F function* measures the distribution of all distances from an arbitrary point in the plane to its nearest event. This function is often called the "empty space function" because it is a measure of the average separation remaining between events. Under the assumption of complete spatial randomness, the expected value of the function F is: F(r)=1-exp{-λπr^2}

This value is identical to the value expected by the G function, this because the points of the Poisson process are independent of each other.

Calculate *F function* with 99 simulations, using `envelope` function with `fun = Fest`:
```{r}
murders_f <- envelope(murders_ppp, fun = Fest, nrank = 2, nsim = 99)
```

Visualize outcomes using default `plot` function:
```{r}
plot(murders_f, main = "F function: Distance from a random point to the nearest murder event in CDMX")
```

## Density

### Global density

(Explicación de la densidad global)

Calculate global density dividing the total murders (using `nrow` function) by the CDMX area (using the `st_area` function):

```{r}
murders_global_density <- nrow(murders_cdmx)/st_area(cdmx_border)
murders_global_density
```

### Local density

Create a 50x50 grid to calculate density by square quadrants:

```{r}
murders_quadrat <- quadratcount(murders_ppp, nx = 50, ny = 50)
plot(murders_quadrat)
```

Calculate kernel density estimate (KDE) using `density.ppp` function, with a 50 sigma value (threshold):
```{r}
murders_kde <- density.ppp(murders_ppp, sigma = 50)
plot(murders_kde, main = "Murders KDE in CDMX")
```

To export density as a raster file, it is needed to assign a coordinate reference system (CRS) using `crs` function and write the file with the `WriteRaster` function:
```{r}
murders_kde_raster <- raster(murders_kde)

crs(murders_kde_raster) <- "+proj=utm +zone=14 +ellps=GRS80 +units=m +no_defs"

writeRaster(murders_kde_raster,
            filename = "Data/murders_kde.tiff",
            format = "GTiff",
            overwrite = TRUE,
            NAflag = -9999)
```


